#ifndef CARCOUNTER_H
#include <stdio.h>  
#include <iostream>
#include <thread>

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/opencv.hpp>

#include <vector>
#include <queue> 

#include "sqlite3.h" 


#define PI 3.14159265358979323846

/* Frame datatype */
/* Holistic reperesentation of all the objects captured in the given frame. */ 
struct Frame
{
	// Geometric describition
	cv::vector<cv::vector<cv::Point>> contour;
	cv::vector<cv::Rect> boundRect;
	cv::vector<cv::Point2f> center;
	cv::vector<float> radius;
	
	// Instanious metrics (based on current frame and the last)  
	cv::vector<double> velocity;
	cv::vector<double> velocityX;
	cv::vector<double> velocityY;

	// Average metrics (based on the entire known history of the object)
	cv::vector<double> speed;
	cv::vector<double> speedX;
	cv::vector<double> speedY;
	cv::vector<double> distance;
	cv::vector<double> distanceX;
	cv::vector<double> distanceY;

	// Meta-data
	cv::vector<int> time;
	cv::vector<int> id;
	cv::vector<bool> p;
	cv::vector<cv::Point2f> start_loc;

	// Calculated prediction of where the object should be in the future
	cv::vector<std::vector<cv::Point2f>> pTraj;
};

/* Object datatype */
/* Repersentation of all objects captured in the footage. */
struct Object
{	
	// Target data
	int id;	
	cv::Point2f start_loc;
	cv::vector<cv::Point2f> trajectory;
	cv::vector<int> area;
	cv::vector<int> frames;
	cv::Mat img;
	
	// Simple flags
	bool car;
	bool miss;
	
	// Variables to track last know state of object.
	int last_seen;
	cv::vector<std::vector<cv::Point2f>> trajectories_before_disappearing;
	cv::vector<cv::Point> contour_before_disappearing;
	cv::Rect boundbox_before_disappearing;
	cv::Point2f center_when_last_seen;
	double velocity_when_last_seen;
	double velocityX_when_last_seen;
	double velocityY_when_last_seen;
	double speed_when_last_seen;
	double speedX_when_last_seen;
	double speedY_when_last_seen;
	double distance_when_last_seen;
	double distanceX_when_last_seen;
	double distanceY_when_last_seen;
	int time_when_last_seen;
};

/* An instance of carCounter can run the algorithm.
 * carCounter also stores result data on cars and all
 * processed frames. An alternative to getting the data
 * from program memory is to pull it from a database. A 
 * carCounter will keep table data updated as the algorithm
 * runs. */

class carCounter{

private:

	// Identifier
	int id;

	// Counters
	int frame_counter;
	int object_counter;
	int car_counter;

	// Workspace
	std::deque<Frame> buffer;	
	std::deque<Object> transit;
	
	// Result
	std::deque<Object> carArchive;
	std::deque<Frame>  frameArchive;

	// Misc.
	cv::Mat frame;				// current frame.  
	cv::Mat background;			// background.
	cv::Mat resizeF;			// current frame resized.
	cv::Mat display;		    // can use this to draw whatever you want on it.

	cv::vector<cv::vector<cv::Point>> contours;
	cv::vector<cv::Vec4i> hierarchy;
	cv::vector<cv::Vec3f> vecCircles;               
	cv::vector<cv::Vec3f>::iterator itrCircles;

	cv::Mat fgMaskMOG2;					// fg mask generated by MOG method.
	cv::Mat3b fgMaskMOG2rgb;            // fg mask with 3 channels for shadow removal.
	cv::BackgroundSubtractorMOG2 MOG2;  // MOG Background subtractor.

	// extra background subtractor.
	cv::Mat efgMaskMOG2;				
	cv::BackgroundSubtractorMOG2 eMOG2;

	// db variables
	sqlite3 *db;
	int rc;

	/*  Initializes the frame object once Background subtraction is done. */

	void createFrame(Frame &data, cv::vector<cv::vector<cv::Point>> &contours,
					 cv::vector<cv::vector<cv::Point>> &contours_poly,
					 cv::vector<cv::Rect> &boundRect,
					 cv::vector<cv::Point2f> &center,
					 cv::vector<float> &radius, int minObjectSize);

	/* Checks what objects in the current frame 
	 * correspond to the ones in the previous */

	void persistenceCheck(cv::Mat &frame, 
						  int &car_counter, int &frame_counter, int &object_counter,
						  int type,
						  std::deque<Frame> &buffer, std::deque<Object> &transit, 
						  cv::vector<cv::Point> startRegion);
    
	
	/* This method keeps tabs on objects that may have went missing */
	
	void checkMissing(int &frame_counter,
					  std::deque<Frame> &buffer,std::deque<Object> &transit);

	/* Checks for new objects entering the transit region.
	 * Objects in the transit region are suspected cars, if they enter they should also leave
	 * at some point. When this happens they are identified as being cars. */

	void startRegionMonitor(std::deque<Frame> &buffer,std::deque<Object> &transit, 
							cv::vector<cv::Point> startRegion);
	
	/* Checks for objects exiting the transit region */

	void endRegionMonitor(cv::Mat &frame,int &car_counter,
						  std::deque<Frame> &buffer,std::deque<Object> &transit, 
						  std::deque<Object> &carArchive,
						  cv::vector<cv::Point> endRegion);

	
	/* Internal functionality for persistenceCheck */
	void checkTransitLedgerUsingMomentAndCenter(cv::Mat &frame, 
												int &car_counter, int &frame_counter, int &object_counter,
												std::deque<Frame> &buffer,std::deque<Object> &transit,		
												cv::vector<cv::Point> startRegion);
	
	/* Visualization */
	void drawResult(int &car_counter, int &object_counter, cv::Mat &frame, cv::vector<cv::Vec4i> &hierarchy, std::deque<Frame> &buffer,std::deque<Object> &transit,
								bool showLastCar, bool boundBoxesOn, bool predictionOn, bool latestPathsOn, bool displayTransitLedger, bool displayFocusRegions, int showPathofId,
								cv::vector<cv::Point> startRegion,
								cv::vector<cv::Point> endRegion);
	
	/* DB functions */
	void openDB();
	void closeDB();

	/* Async method for filling the database */
	void exportCarsToDB(int expID, std::deque<Object> &carArchive);

public:
	// constructor
	carCounter(int expID);

	/* This call is made to run the algorithm */
	void run(int bufferSize, int minObjectSize, int skip, int learningTime, char fileName[100], 
		bool online, const cv::Point* ppt, const cv::Point* ppt2,int* npt,int* npt2,
		int nmixtures, double backgroundratio, bool detectShadows, bool showLastCar,
		bool boundBoxesOn, bool predictionOn, bool latestPathsOn, 
		bool displayTransitLedger, bool displayFocusRegions, int showPathofId,
		int displayType,
		cv::vector<cv::Point> startRegion,
		cv::vector<cv::Point> endRegion);

	/* Getters for the results */
	void getFrameArchiveData(int* frames);
	void getCarArchiveData(int* cars);
};

static int callback(void *NotUsed, int argc, char **argv, char **azColName);

#endif